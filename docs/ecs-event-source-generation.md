# Arch.EventBus Source Generation Guide

This document explains how to integrate Arch.EventBus source generation with the PokeSharp ECS event system.

## Installation

Add the Arch.EventBus NuGet package to your project:

```xml
<ItemGroup>
  <PackageReference Include="Arch.EventBus" Version="2.1.0" />
</ItemGroup>
```

## Source Generation Attributes

Arch.EventBus uses source generators to create optimized event dispatching code at compile-time.

### Basic Event Registration

```csharp
using Arch.EventBus;

namespace PokeSharp.Engine.Core.Events.ECS;

// Mark the event bus class for source generation
[Event]
public partial class ArchEcsEventBus : IEcsEventBus
{
    // Source generator will create optimized Subscribe/Publish methods
}
```

### Event Type Registration

For optimal performance, explicitly register event types:

```csharp
[Event]
[RegisterEvent<MapLoadedEvent>]
[RegisterEvent<PlayerMovedEvent>]
[RegisterEvent<TileEnteringEvent>]
[RegisterEvent<ComponentChangedEvent<Health>>]
public partial class ArchEcsEventBus : IEcsEventBus
{
    // Generated code will include specialized handlers for these types
}
```

## Generated Code Structure

Arch.EventBus generates the following methods (simplified example):

```csharp
// Generated by Arch.EventBus source generator
partial class ArchEcsEventBus
{
    private readonly Dictionary<Type, List<Delegate>> _generatedHandlers = new();

    // Generated Subscribe method
    public IDisposable Subscribe<TEvent>(Action<TEvent> handler)
        where TEvent : struct
    {
        var eventType = typeof(TEvent);
        if (!_generatedHandlers.TryGetValue(eventType, out var handlers))
        {
            handlers = new List<Delegate>();
            _generatedHandlers[eventType] = handlers;
        }

        handlers.Add(handler);
        return new Subscription(() => handlers.Remove(handler));
    }

    // Generated Publish method
    public void Publish<TEvent>(TEvent evt)
        where TEvent : struct
    {
        var eventType = typeof(TEvent);
        if (_generatedHandlers.TryGetValue(eventType, out var handlers))
        {
            foreach (var handler in handlers)
            {
                ((Action<TEvent>)handler)(evt);
            }
        }
    }
}
```

## Custom Implementation

Since we need priority ordering and cancellation, we wrap the generated code:

```csharp
[Event]
public partial class ArchEcsEventBus : IEcsEventBus
{
    private readonly ConcurrentDictionary<Type, HandlerCollection> _priorityHandlers = new();

    // Our custom implementation wraps the generated code
    public new IDisposable Subscribe<TEvent>(Action<TEvent> handler, EventPriority priority)
        where TEvent : struct, IEcsEvent
    {
        var collection = _priorityHandlers.GetOrAdd(typeof(TEvent), _ => new HandlerCollection());
        var handlerId = Interlocked.Increment(ref _nextHandlerId);

        var wrapper = new HandlerWrapper<TEvent>(handlerId, handler, priority);
        collection.Add(wrapper);

        return new EcsSubscription(this, typeof(TEvent), handlerId);
    }

    public new void Publish<TEvent>(TEvent evt)
        where TEvent : struct, IEcsEvent
    {
        if (!_priorityHandlers.TryGetValue(typeof(TEvent), out var collection))
        {
            // No handlers - use generated fast path
            base.Publish(evt);
            return;
        }

        // Sort handlers by priority and execute
        var handlers = collection.GetSortedHandlers<TEvent>();
        foreach (var wrapper in handlers)
        {
            wrapper.Handler(evt);
        }
    }
}
```

## Performance Characteristics

### With Source Generation

- **Compile-time optimization**: No reflection at runtime
- **Type-safe dispatch**: Direct method calls, no casting overhead
- **Zero allocation**: Struct events passed by value
- **Inline-friendly**: JIT can inline event dispatch

### Benchmarks (Estimated)

```
Publishing 1000 events with 10 handlers:

With Source Generation:    0.05ms (20,000 events/ms)
Without (Reflection):      0.50ms (2,000 events/ms)
Legacy (TypeEventBase):    1.20ms (833 events/ms)

Memory Allocation:
With Source Generation:    0 bytes
Without (Reflection):      40 KB
Legacy (TypeEventBase):    120 KB
```

## Build Configuration

### Enable Source Generators

Ensure source generators are enabled in your `.csproj`:

```xml
<PropertyGroup>
  <LangVersion>latest</LangVersion>
  <Nullable>enable</Nullable>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
  <CompilerGeneratedFilesOutputPath>$(BaseIntermediateOutputPath)Generated</CompilerGeneratedFilesOutputPath>
</PropertyGroup>

<ItemGroup>
  <!-- Exclude generated files from source control -->
  <None Remove="$(CompilerGeneratedFilesOutputPath)/**/*.cs" />
</ItemGroup>
```

### View Generated Code

Generated code appears in `obj/Generated/` during compilation. Example:

```
obj/
  Generated/
    Arch.EventBus/
      Arch.EventBus.Generator/
        ArchEcsEventBus.g.cs
```

## Debugging Generated Code

### Step 1: Enable Generated File Output

```xml
<PropertyGroup>
  <EmitCompilerGeneratedFiles>true</EmitCompilerGeneratedFiles>
</PropertyGroup>
```

### Step 2: View Generated Files

Navigate to `obj/Generated/Arch.EventBus/` to see the generated code.

### Step 3: Set Breakpoints

You can set breakpoints in generated files for debugging (IDE-dependent).

## Common Issues

### Issue: Events Not Dispatching

**Cause**: Event type not registered or handler not subscribed.

**Solution**: Ensure `[RegisterEvent<T>]` attribute is present and handlers are subscribed.

```csharp
[Event]
[RegisterEvent<MyCustomEvent>]
public partial class ArchEcsEventBus : IEcsEventBus
{
    // ...
}
```

### Issue: Compilation Errors

**Cause**: Partial class mismatch or missing using statements.

**Solution**: Ensure the event bus class is marked `partial` and all necessary namespaces are imported.

```csharp
using Arch.EventBus;

namespace PokeSharp.Engine.Core.Events.ECS;

[Event]
public partial class ArchEcsEventBus : IEcsEventBus
{
    // Must be partial!
}
```

### Issue: Performance Not Improved

**Cause**: Not using struct events or boxing occurring.

**Solution**: Ensure events are `readonly struct` and no boxing happens:

```csharp
// ✅ GOOD: Struct event
public readonly struct MyEvent : IEcsEvent
{
    public required float Timestamp { get; init; }
    public required EventPriority Priority { get; init; }
}

// ❌ BAD: Class event (boxes, allocates)
public class MyEvent : IEcsEvent
{
    // ...
}
```

## Integration Checklist

- [ ] Install `Arch.EventBus` NuGet package
- [ ] Mark event bus class with `[Event]` attribute
- [ ] Make event bus class `partial`
- [ ] Register all event types with `[RegisterEvent<T>]`
- [ ] Define events as `readonly struct`
- [ ] Implement `IEcsEvent` interface on all events
- [ ] Enable source generator output for debugging
- [ ] Verify generated code in `obj/Generated/`
- [ ] Run performance benchmarks
- [ ] Add integration tests

## Advanced: Custom Source Generation

If you need custom event handling logic, you can create your own source generator:

```csharp
[Generator]
public class EcsEventGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // Register syntax receiver
    }

    public void Execute(GeneratorExecutionContext context)
    {
        // Generate custom event handling code
    }
}
```

This allows full control over generated code while maintaining performance.

## See Also

- [Arch.EventBus Documentation](https://github.com/genaray/Arch.EventBus)
- [C# Source Generators](https://learn.microsoft.com/en-us/dotnet/csharp/roslyn-sdk/source-generators-overview)
- [ECS Event System Design](ecs-event-system-design.md)
